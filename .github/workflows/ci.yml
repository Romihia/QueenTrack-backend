name: CI/CD Pipeline

on:
  push:
    branches:
      - stage
      - main

jobs:
  # Job ×œ×‘×“×™×§×•×ª ×•-Docker
  validate-and-docker:
    runs-on: ubuntu-latest

    steps:
      # Checkout ×©×œ ×”×§×•×“
      - name: Checkout code
        uses: actions/checkout@v4

      # Setup Python
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.9"

      # ×›××©×¨ ×‘×•×“×§×™× ××ª branch 'stage', × ×‘×¦×¢ ×‘×“×™×§×•×ª
      - name: Install dependencies and run tests
        if: github.ref == 'refs/heads/stage'
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          if [ -f pytest ]; then pytest; fi

      # ×‘×•×“×§×™× ×©×”-Docker Image × ×‘× ×” ×•×¢×•×‘×“
      - name: Build Docker Image
        run: docker build -t queentrack-backend:latest .

      - name: Run Docker Container (Test)
        run: |
          docker run --name queentrack-backend-test -d -p 8000:8000 queentrack-backend:latest
          sleep 15
          docker ps

      # ×‘×“×™×§×ª ×‘×¨×™××•×ª ×”×§×•× ×˜×™×™× ×¨
      - name: Health Check
        run: |
          # ×‘×“×™×§×” ×× ×”×©×™×¨×•×ª ××’×™×‘
          for i in {1..5}; do
            if curl -f http://localhost:8000/health 2>/dev/null || curl -f http://localhost:8000/ 2>/dev/null; then
              echo "âœ… Health check passed"
              break
            else
              echo "â³ Attempt $i failed, retrying in 5 seconds..."
              sleep 5
            fi
          done

      # ×¢×¦×™×¨×ª ×”×§×•× ×˜×™×™× ×¨
      - name: Stop Docker Container
        if: always()
        run: |
          docker stop queentrack-backend-test || true
          docker rm queentrack-backend-test || true

  # Job ××•×˜×•××˜×™ ×œ××¢×‘×¨ ×-stage ×œ-main
  auto-merge-to-main:
    if: github.ref_name == 'stage'
    needs: validate-and-docker
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions@github.com"

      - name: Merge stage to main
        run: |
          echo "ğŸ”„ Starting automatic merge from stage to main..."

          # Switch to main branch
          git checkout main
          git pull origin main

          # Merge stage into main
          echo "ğŸ”€ Merging stage branch into main..."
          git merge origin/stage --no-ff -m "ğŸ¤– Auto-merge: stage â†’ main (validated by CI/CD)"

          # Push the merged changes
          echo "ğŸ“¤ Pushing merged changes to main..."
          git push origin main

          echo "âœ… Successfully merged stage to main!"

  # Job ××•×˜×•××˜×™ ×œ×¤×¨×™×¡×” ×œ×¤×¨×•×“×§×©×Ÿ
  deploy-to-production:
    if: github.ref == 'refs/heads/main'
    needs: validate-and-docker
    runs-on: ubuntu-latest

    environment:
      name: production
      url: "http://162.55.53.52:8000"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Create production environment file from secrets
      - name: Create production environment file
        run: |
          echo "ğŸ” Creating .env.production from GitHub secrets..."

          # Create .env.production from secret
          if [ -n "${{ secrets.PRODUCTION_ENV_FILE }}" ]; then
            echo "${{ secrets.PRODUCTION_ENV_FILE }}" > .env.production
            echo "âœ… .env.production created successfully"
            echo "ğŸ“‹ Environment file size: $(wc -l < .env.production) lines"
          else
            echo "âŒ ERROR: PRODUCTION_ENV_FILE secret not found!"
            echo "Please add the PRODUCTION_ENV_FILE secret to GitHub repository settings"
            exit 1
          fi

          # Validate docker-compose file
          if [ ! -f "docker-compose.prod.yml" ]; then
            echo "âš ï¸ WARNING: docker-compose.prod.yml not found, will use docker-compose.yml"
          fi

          echo "âœ… Deployment files validated"

      # Create production environment file from secrets
      - name: Create production environment file
        run: |
          echo "ğŸ” Creating .env.production from GitHub secrets..."

          # Create .env.production from secret
          if [ -n "${{ secrets.PRODUCTION_ENV_FILE }}" ]; then
            echo "${{ secrets.PRODUCTION_ENV_FILE }}" > .env.production
            echo "âœ… .env.production created successfully"
            echo "ğŸ“‹ Environment file size: $(wc -l < .env.production) lines"
          else
            echo "âŒ ERROR: PRODUCTION_ENV_FILE secret not found!"
            echo "Please add the PRODUCTION_ENV_FILE secret to GitHub repository settings"
            exit 1
          fi

          # Validate docker-compose file
          if [ ! -f "docker-compose.prod.yml" ]; then
            echo "âš ï¸ WARNING: docker-compose.prod.yml not found, will use docker-compose.yml"
          fi

          echo "âœ… Deployment files validated"

      # ×”×›× ×ª ××¤×ª×— SSH
      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.PRODUCTION_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts

      # ×™×¦×™×¨×ª ×ª×™×§×™×™×ª ×”×¤×¨×•×™×§×˜ ×‘×©×¨×ª
      - name: Create project directory
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "mkdir -p /QueenTrack-backend"

      # ×”×¢×‘×¨×ª ×§×‘×¦×™ ×”×¤×¨×™×¡×” ×œ×©×¨×ª
      - name: Copy deployment files to server
        run: |
          # Copy all necessary files
          scp -i ~/.ssh/id_rsa -r ./* ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:/QueenTrack-backend/ || true

          # Ensure .env.production is copied (critical for deployment)
          if [ -f ".env.production" ]; then
            echo "ğŸ“„ Copying .env.production to server..."
            scp -i ~/.ssh/id_rsa .env.production ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:/QueenTrack-backend/
            echo "âœ… .env.production copied successfully"
          else
            echo "âŒ ERROR: .env.production file not found locally!"
            exit 1
          fi

          # Copy docker-compose.prod.yml
          if [ -f "docker-compose.prod.yml" ]; then
            echo "ğŸ“„ Copying docker-compose.prod.yml to server..."
            scp -i ~/.ssh/id_rsa docker-compose.prod.yml ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }}:/QueenTrack-backend/
            echo "âœ… docker-compose.prod.yml copied successfully"
          else
            echo "âš ï¸ Warning: docker-compose.prod.yml not found"
          fi

          # Verify files were copied
          echo "ğŸ” Verifying files on server..."
          ssh -i ~/.ssh/id_rsa ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} "ls -la /QueenTrack-backend/.env* || echo 'No .env files found'"

      # ×‘×™×¦×•×¢ ×¤×¨×™×¡×” ××•×˜×•××˜×™×ª
      - name: Deploy to Production Server
        env:
          GITHUB_REPO: ${{ github.repository }}
        run: |
          ssh -i ~/.ssh/id_rsa ${{ secrets.PRODUCTION_USER }}@${{ secrets.PRODUCTION_HOST }} << EOF
            set -e
            echo "ğŸš€ Starting QueenTrack deployment process..."
            
            # Navigate to project directory
            cd /QueenTrack-backend
            
            # Setup Git if not already done
            if [ ! -d ".git" ]; then
              echo "ğŸ“¥ Initializing git repository..."
              git init
              git remote add origin "https://github.com/${GITHUB_REPO}.git"
            fi
            
            # Pull latest code from main branch
            echo "ğŸ“¥ Pulling latest code from main branch..."
            git fetch origin main || echo "Fetch failed, continuing with existing code"
            git checkout main 2>/dev/null || git checkout -b main
            
            # Setup production environment
            echo "âš™ï¸ Setting up production environment..."
            if [ -f ".env.production" ]; then
                cp .env.production .env
                echo "âœ… Production environment configured from .env.production"
                echo "ğŸ” Environment file contents (first 5 lines):"
                head -5 .env
            else
                echo "âŒ ERROR: .env.production file not found on server!"
                echo "ğŸ“ Files in current directory:"
                ls -la
                exit 1
            fi
            
            # Verify environment setup before proceeding
            echo "ğŸ” Verifying environment setup..."
            if [ -f ".env" ]; then
                echo "âœ… .env file exists"
                echo "ğŸ“‹ Key environment variables:"
                grep -E "^(MONGO_URI|MONGO_DB_NAME|ENV|SERVER_PORT)=" .env | sed 's/=.*/=***/' || echo "Environment variables not found"
            else
                echo "âŒ ERROR: .env file still not found after setup!"
                exit 1
            fi
            
            # Stop existing containers
            echo "ğŸ›‘ Stopping existing containers..."
            if [ -f "docker-compose.prod.yml" ]; then
              docker compose -f docker-compose.prod.yml down || true
            else
              echo "âš ï¸ docker-compose.prod.yml not found, using docker-compose.yml"
              docker compose down || true
            fi
            
            # Clean up old Docker images
            echo "ğŸ§¹ Cleaning up old Docker images..."
            docker system prune -f || true
            
            # Build and start new containers
            echo "ğŸ”¨ Building and starting new containers..."
            if [ -f "docker-compose.prod.yml" ]; then
              docker compose -f docker-compose.prod.yml up --build -d
            else
              docker compose up --build -d
            fi
            
            # Wait for services to start
            echo "â³ Waiting for services to start..."
            sleep 30
            
            # Health check
            echo "ğŸ¥ Checking service health..."
            COMPOSE_FILE="docker-compose.prod.yml"
            if [ ! -f "\$COMPOSE_FILE" ]; then
              COMPOSE_FILE="docker-compose.yml"
            fi
            
            if docker compose -f \$COMPOSE_FILE ps | grep -q "Up"; then
              echo "âœ… Deployment successful! Service is running."
              docker compose -f \$COMPOSE_FILE ps
            else
              echo "âŒ Deployment failed! Service is not running."
              docker compose -f \$COMPOSE_FILE logs --tail=50
              exit 1
            fi
            
            echo "ğŸ‰ Deployment completed successfully!"
          EOF

      # ×‘×“×™×§×ª ×‘×¨×™××•×ª ××¨×—×•×§
      - name: Final Health Check
        run: |
          echo "ğŸ” Performing final health check..."
          sleep 15

          # ×‘×“×™×§×” ×× ×”×©×™×¨×•×ª ××’×™×‘ ××”××™× ×˜×¨× ×˜
          for i in {1..5}; do
            if curl -f "http://${{ secrets.PRODUCTION_HOST }}:8000/health" 2>/dev/null || curl -f "http://${{ secrets.PRODUCTION_HOST }}:8000/" 2>/dev/null; then
              echo "âœ… Final health check passed!"
              break
            else
              echo "â³ Health check attempt $i failed, retrying in 10 seconds..."
              sleep 10
            fi
          done

      # ×”×ª×¨××” ×¢×œ ×”×¦×œ×—×”
      - name: Deployment Success Notification
        if: success()
        run: |
          echo "ğŸ‰ SUCCESS: QueenTrack Backend deployed to production!"
          echo "ğŸŒ Production URL: http://${{ secrets.PRODUCTION_HOST }}:8000"
          echo "ğŸ“Š Monitor service with SSH and run: docker compose ps"
          echo "ğŸ“‹ View logs with SSH and run: docker compose logs"

      # ×”×ª×¨××” ×¢×œ ×›×™×©×œ×•×Ÿ
      - name: Deployment Failure Notification
        if: failure()
        run: |
          echo "âŒ FAILURE: QueenTrack Backend deployment failed!"
          echo "ğŸ” Check the logs above for more details"
          echo "ğŸ› ï¸ Connect to server via SSH to troubleshoot"
